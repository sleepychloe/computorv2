1. rational number
	$./computorv2
	> varA = 2
	2
	> varB = 4.242
	4.242
	> varC = -4.3
	-4.3
	>
2. imaginary number
	$./computorv2
	> varA = 2*i + 3
	3 + 2i
	> varB = -4i - 4
	-4 - 4i
	>
3. matrix
	$./computorv2
	> varA = [[2,3];[4,3]]
	[ 2 , 3 ]
	[ 4 , 3 ]
	> varB = [[3,4]]
	[ 3 , 4 ]
	>
4. function with only one variable
	$./computorv2
	> funA(x) = 2*x^5 + 4x^2 - 5*x + 4
	2 * x^5 + 4 * x^2 - 5*x + 4
	> funB(y) = 43 * y / (4 % 2 * y)
	43 * y / (4 % 2 * y)
	> funC(z) = -2 * z - 5
	-2 * z - 5
	>
5. reassign variable
	$./computorv2
	> x = 2
	2
	> y = x
	2
	> y = 7
	7
	> y = 2 * i - 4
	-4 + 2i
	>

	$./computorv2
	> varA = 2 + 4 *2 - 5 %4 + 2 * (4 + 5)
	27
	> varB = 2 * varA - 5 %4
	53
	> funA(x) = varA + varB * 4 - 1 / 2 + x
	238.5 + x
	> varC = 2 * varA - varB
	1
	> varD = funA(varC)
	239.5
	>


operation:
	1. +, -, *, /, %
	2. **	: standard matrix multiplication
			ex: varA = [[1, 2];[3, 4]]
			    varB = [[5, 6];[7, 8]]
			    -> varA**varB = [[1*5+2*7, 1*6+2*8];[3*5+4*7, 3*6+4*8]]
			    		  = [[19, 22];[43, 50]]
	3. *	: term-to-term multiplication of two matrices(=Hadamard product),
			scalar and a matrix
			ex1: varA = [[1, 2];[3, 4]]
			     varB = [[5, 6];[7, 8]]
			     -> varA*varB = [[1*5, 2*6];[3*7, 4*8]]
			    		  = [[5, 12];[21, 48]]
			ex2: varA = 3
			     varB = [[1, 2];[3, 4]]
			     -> varA*varB = [[3*1, 3*2];[3*3, 3*4]]
			    		  = [[3, 6];[9, 12]]
	4. ^	: integer and positive powers(or zero)
			base: any number
			power: 0, positiver integer, negative integer when base is not 0
			(n^0 = 1 for any n != 0,
			 don't have to handle negative like n^-3, 
			 nor non integer power like n^1.4)
	5. () allowed
	6. function/variable = ?
		: returns the value of the variable
			$./computorv2
			> a = 2 * 4 + 4
			12
			> a + 2 = ?
			14
			>
		
			$./computorv2
			> funA(x) = 2 * 4 + x
			8 + x
			> funB(x) = 4 -5 + (x + 2)^2 - 4
			(x + 2)^2 - 5
			> funC(x) = 4x + 5 - 2
			4 * x + 3
			> funA(2) + funB(4) = ?
			41
			> funC(3) = ?
			15
			>
	7. computation of the square roots of polynomials when the degree is less than or equal to 2,
		proposing on R or C
			$./computorv2
			> funA(x) = x^2 + 2x + 1
			x^2 + 2x + 1
			> y = 0
			0
			> funA(x) = y ?
			x^2 + 2x + 1 = 0
			Une solution sur R :
			-1
			>


syntax:
	1. variable/function name should only contain letters, must be case insensitive
		-> varA and vara is identical
		-> varA(=vara) and A(=a) are different variable
	2. no variable can be called i
	3. at each input validation, display the value stored in thre variable
		$./computorv2
		> varA = 2
		2
		> varB= 2 * (4 + varA + 3)
		18
		> varC =2 * varB
		36
		> varD    =    2 *(2 + 4 *varC -4 /3)
		289.333333333
		>
	4. 2 ∗ xx does not mean 2 ∗ x2 nor 2 ∗ x, xx here is considered as a variable

	-> didn't mention variable/function name should only contain same character,
		: varXYZ(=varxyz), funAAAA(AAAAA)(=funcaaaa(aaaa)) are valid
	5. matrix syntax: [[A0,0 , A0,1 , ...]; [A1,0 , A1,1 , ...]; ...]
		ex6. [[1]]	     : valid
		ex6. [[1];[2]]	     : valid
		ex1. [[1,2];[3,4]]   : valid
		ex6. [[1];]	     : invalid
		ex6. [[1,]]	     : invalid
	6. function syntax: form of functionName(variable) = ...
		-> AAAAA(aaaa) is valid




* every input should contain =

' ','\t',
'a' to 'z', 'A' to 'Z',
'0' to '9', '.', '(', ')', '[', ']', ';', ',', '=', '?', '+', '-', '*', '/', '%', '^'


-----------------------------------------------------------------------

<modulo> - choosed math way
in math: a % b = r (where r = a - b*floor(a/b), 0 <= r < abs(b))
	(floor(a / b): the greatest integer less than or equal to a/b
	  -> result of the division is rounded down to the nearest integer)
	ex1: 7 % 3 = 7 - 3*floor(7/3) = 7 - 3*2 = 1
	ex2: -7 % 3 = -7 -3*floor(-7/3) = -7 - 3*(-3) = 2
	ex3: 7 % -3 = 7 - (-3)*floor(7/-3) = 7 - (-3)*(-3) = -2
	ex4: -7 % -3 = -7 - (-3)*floor(-7/-3) = -7 - (-3)*2 = -1

in c, c++: result has same sign as the dividend
	ex1: 7 % 3 = +(abs(7) % abs(3)) = 1
	ex2: -7 % 3 = -(abs(7) % abs(3)) = -1
	ex3: 7 % -3 = +(abs(7) % abs(3)) = 1
	ex4: -7 % -3 = -(abs(7) % abs(3)) = -1

-----------------------------------------------------------------------

1. check equal(=) sign
2. check invalid character
3. check number, check float point
4. remove space
5. convert operator
	- whenever it finds sqare bracket,
		make substr([...]),
		check its square brackets are pair,
		if it's vector or matrix
			-> check vector/matrix form,
				convert operator,
				check round bracket,
				check operator
	- otherwise continue converting operator
6. check syntax
	- round bracket(left, right term seperately)
	- square bracket(left, right term seperately)
	- check operator(left, right term seperately)
		-> skip round and square brackets





** when round brackets get removed, check operator first



---------------------------------
wrong equation
---------------------------------
adfasdfasf
adfasdf=
adfasdf=     
       =sfsdf
a == a
a = a = a

---------------------------------
wrong number, wrong float point
---------------------------------
x^2+1 1=0
x^2+1=0 0
x^2+.1=0
x^2+1.=0
x^2+1..0=0
x^2+1.0.0=0

---------------------------------
wrong syntax round bracket
---------------------------------
x^2+((1)=0
x^2+(1))=0
x^2+(1=0)
x^2+)1(=0
x^2+1()=0
(x^2))+((1)=0

---------------------------------
wrong syntax square bracket
---------------------------------
x^2+[[1]=0
x^2+[1]]=0
x^2+[1=0]
x^2+]1[=0
x^2+1[]=0
[x^2]]+[[1]=0

---------------------------------
wrong syntax bracket mixed
---------------------------------
([)]=0
([1)2]=0
(1[2)]=0
(1[2)3]=0

---------------------------------
wrong vector form
---------------------------------
a=[];
a=[,];
a=[1,];
a=[1,2];
a=[1,2,];
a=[1,2,,3];
a=[]
a=[,]
a=[1,]
a=[1,2,]
a=[1,2,,3]

---------------------------------
wrong matrix form
---------------------------------
a=[[]]
a=[[1,]]
a=[[1];]
a=[[1,2,]]
a=[[1,,2]]
a=[[1,2];]
a=[[1];[2,]]
a=[[1];[2];]
a=[[1];[2,3]]
a=[[1,2];[[3];[4]]]
a=[[1,2];[[3,4]]]
a=[[]];
a=[[1,]];
a=[[1];];
a=[[1,2,]];
a=[[1,,2]];
a=[[1,2];];
a=[[1];[2,]];
a=[[1];[2];];
a=[[1];[2,3]];
a=[[1,2];[[3];[4]]];
a=[[1,2];[[3,4]]];

---------------------------------
wrong syntax operator
---------------------------------
x^2++1=0
x^2+-1=0
x^2+*1=0
x^2+**1=0
x^2+/1=0
x^2+%1=0
x^2-+1=0
x^2--1=0
x^2-*1=0
x^2-**1=0
x^2-/1=0
x^2-%1=0
x^2*+1=0
x^2*-1=0
x^2***1=0
x^2*/1=0
x^2*%1=0
x^2**+1=0
x^2**-1=0
x^2***1=0
x^2****1=0
x^2**/1=0
x^2**%1=0
x^2/+1=0
x^2/-1=0
x^2/*1=0
x^2/**1=0
x^2//1=0
x^2/%1=0
*x^2+1=0
**x^2+1=0
/x^2+1=0
%x^2+1=0
x^2+1+=0
x^2+1-=0
x^2+1*=0
x^2+1**=0
x^2+1/=0
x^2+1%=0
x^2+1=*0
x^2+1=**0
x^2+1=/0
x^2+1=%0
x^2+1=0+
x^2+1=0-
x^2+1=0*
x^2+1=0**
x^2+1=0/
x^2+1=0%





---------------------------------
right
---------------------------------
(5*3/2+1)*x*x^1+(+(-1))/(-2)*x^1+3*1/2=0
((2+4+6x-1*(3x-3+1*3*(-2)*(+1*2*(-1)*(-1)*(+3x)*2+x+3)*(-1)*(2)))+3)-1=0
2*(2x+3)*(x+x)*2/2/2+1+x= 0

---------------------------------
wrong
---------------------------------
(5*3/2+1)*x*x^1+(+(-1)/(-2)*x^1+3*1/2=0
((2+4+6x-1*(3x-3+1*3*-2)*(+1*2*(-1)*(-1)*(+3x)*2+x+3)*(-1)*(2)))+3)-1=0






a**b=+3332*abcdef+3.22%2+iiiii*(+2/-2)+32
a**b=+3332*abcdef+3.22%2+[+1,-2,+3]+[[+1,-2];[+3,-3];[1,-3]]-(-iiiii)*(+2/2)+32
a=  [ [+1,-2]; [-3,-2]; [-1,-2]] ** -1*[ [+1,-2]; [-1, +2];[-3,-2]; [-1,-2]]
a=  [ [+1,-1]; [-3,-2]; [-1,-3]] ** -1*[ [+1,-4]; [-1, +5];[-3,-6]; [-1,-7]]
a=  -1*[+3,-2]-[+12,3]*3+[-1,-2]